/**
 * @file **Inaccurate** XPath prosedures.
 */

import {ParsedElement} from "./domParser"
import { svgVirtualMap, svgdata } from "./main";

/**
 * Search by xpath.
 * @param xpath Only accept limited notation generated by `xpath` function bellow.
 */
export function search(pe: ParsedElement, xpath: string): ParsedElement | null {
    let ret: RegExpMatchArray | null;
    if (xpath.startsWith("/")) {
        return search(svgdata, xpath.slice(1));
    } else if (xpath) {
        if ("children" in pe && (ret = xpath.match(/^([^/]+)(\[\d+\])?/))) {
            const tag = ret[1];
            const oneBasedIndex = ret[2] && Number(ret[2]) || 1;
            const nextPe = pe.children.filter(x => x.tag === tag).find((_value, index) => index + 1 === oneBasedIndex);
            return nextPe && search(nextPe, xpath.slice(ret[0].length)) || null;
        } else {
            return null;
        }
    } else {
        return pe;
    }
}

/**
 * Calc unique xpath.
 */
export function xpath(pe: ParsedElement): string {
    if (pe.parent) {
        const parentPe = svgVirtualMap[pe.parent];
        const sameTagCount = "children" in parentPe ? parentPe.children.filter(x => x.tag === pe.tag).length : 0;
        const oneBasedIndex = "children" in parentPe ? parentPe.children.filter(x => x.tag === pe.tag).findIndex(x => x.uuid === pe.uuid) + 1 : 0;
        return `${xpath(parentPe)}/${pe.tag}${sameTagCount <= 1 ? "" : `[${oneBasedIndex}]`}`;
    } else {
        return `/${pe.tag}`;
    }
}
